%function create_gwc_file(type, numSamplePts, sampleRange, gwc_filename)
%clear
type=6;
numSamplePts=[60 60 60]*2;
sampleRange=[-200 -200 -200;200 200 200]*2;
%gwc_filename='sonata.gwc';

if (type==0)        % Sonata
    sp=gradParamsSonata1;
    booldiff=false;
    %sp=gradParamsSonata_new;
    %booldiff=true;
    dlfn='siemens_sonata_dL.mgh';
    dpfn='siemens_sonata_dP.mgh';
    dhfn='siemens_sonata_dH.mgh';
%     jxfn='siemens_sonata_jx.mgh';
%     jyfn='siemens_sonata_jy.mgh';
%     jzfn='siemens_sonata_jz.mgh';
    %jacdetfn='siemens_sonata_jacdet.mgh';
elseif (type==1)   % Allegra
    sp=gradParamsAllegra_new3;
    booldiff=true;
    dlfn='siemens_allegra_dL.mgh';
    dpfn='siemens_allegra_dP.mgh';
    dhfn='siemens_allegra_dH.mgh';
%     jxfn='siemens_allegra_jx.mgh';
%     jyfn='siemens_allegra_jy.mgh';
%     jzfn='siemens_allegra_jz.mgh';
    %jacdetfn='siemens_allegra_jacdet.mgh';
elseif (type==2) % Avanto
    sp=gradParamsAvanto;
    booldiff=true;
    dlfn='siemens_avanto_dL.mgh';
    dpfn='siemens_avanto_dP.mgh';
    dhfn='siemens_avanto_dH.mgh';
elseif (type==3) % Axxess
    sp=gradParamsAxxess;
    booldiff=true;
    dlfn='siemens_axxess_dL.mgh';
    dpfn='siemens_axxess_dP.mgh';
    dhfn='siemens_axxess_dH.mgh';   
 elseif (type==4) % Quantum
    sp=gradParamsQuantum;
    booldiff=true;
    dlfn='siemens_quantum_dL.mgh';
    dpfn='siemens_quantum_dP.mgh';
    dhfn='siemens_quantum_dH.mgh'; 
elseif (type==5) % Skyra
    sp=gradParamsSkyra;
    booldiff=true;
    dlfn='siemens_skyra_dL.mgh';
    dpfn='siemens_skyra_dP.mgh';
    dhfn='siemens_skyra_dH.mgh';
elseif (type==6) % ConnectomeSkyra
    sp=gradParamsConnectomeSkyra;
    booldiff=true;
    dlfn='siemens_connectome_dL.mgh';
    dpfn='siemens_connectome_dP.mgh';
    dhfn='siemens_connectome_dH.mgh';             
elseif (type==7) % Prisma
    sp=gradParamsPrisma;
    booldiff=true;
    dlfn='siemens_prisma_dL.mgh';
    dpfn='siemens_prisma_dP.mgh';
    dhfn='siemens_prisma_dH.mgh';             
elseif (type==8) % Verio
    sp=gradParamsVerio;
    booldiff=true;
    dlfn='siemens_verio_dL.mgh';
    dpfn='siemens_verio_dP.mgh';
    dhfn='siemens_verio_dH.mgh';
elseif (type==9) % Vida
    sp=gradParamsVida;
    booldiff=true;
    dlfn='siemens_vida_dL.mgh';
    dpfn='siemens_vida_dP.mgh';
    dhfn='siemens_vida_dH.mgh';              
elseif (type==10) % Cima.X
    sp=gradParamsCimaX;
    booldiff=true;
    dlfn='siemens_CimaX_dL.mgh';
    dpfn='siemens_CimaX_dP.mgh';
    dhfn='siemens_CimaX_dH.mgh';
else      
    disp ('Unkown Gradient type...');
    error('Exiting ...');
end


% Parse number of sample points
if size(numSamplePts, 1) ~= 1
  fprintf('\n%s: numSamplePts is not the right size\n\n', ...
	  mfilename);
  error('Exiting ...');
else
  if size(numSamplePts, 2) == 1
    numSamplePts = repmat(numSamplePts, 1, 3);
  end
end
n_l = numSamplePts(1); n_p = numSamplePts(2); n_h = numSamplePts(3);

% Parse the range (bounding box) of the sample points
if size(sampleRange, 1) ~= 2
  fprintf('\n%s: sampleRange is not the right size\n\n', ...
	  mfilename);
  error('Exiting ...');
else
  if size(sampleRange, 2) == 1 
    sampleRange = repmat(sampleRange, 1, 3);
  end
end

%%% Convert from units of mm to meters
sampleRange = sampleRange;

%%% Make later code more readable
min_l = sampleRange(1,1); min_p = sampleRange(1,2); min_h = sampleRange(1,3);
max_l = sampleRange(2,1); max_p = sampleRange(2,2); max_h = sampleRange(2,3); 

% Create the sample points
[L, P, H] = meshgrid(linspace(min_l, max_l, n_l), ...
		     linspace(min_p, max_p, n_p), ...
		     linspace(min_h, max_h, n_h));



%%% mySiemens_B computes the values of B for each grad coil 
%%% (Bx is field generated by the x-coil, in the z-direction, etc.)

BL = mySiemens_B(sp.Alpha_x, sp.Beta_x, L, -P, -H, sp.R0);
BP = -mySiemens_B(sp.Alpha_y, sp.Beta_y, L, -P, -H, sp.R0);
BH = -mySiemens_B(sp.Alpha_z, sp.Beta_z, L, -P, -H, sp.R0);
%%% Compute displacement & convert to mm
if (booldiff==false)
    dL = (BL-L);
    dP = (BP-P);
    dH = (BH-H);
    %dL=reshape(dL, n_y, n_x, n_z);
    %dP=reshape(dP, n_y, n_x, n_z);
    %dH=reshape(dH, n_y, n_x, n_z);
else
    dL = (BL);
    dP = (BP);
    dH = (BH);
    %dX=reshape(BL, n_y, n_x, n_z);
    %dY=reshape(BP, n_y, n_x, n_z);
    %dZ=reshape(BH, n_y, n_x, n_z);
end


dl = (max_l-min_l)/(n_l-1); dp = (max_p-min_p)/(n_p-1);; dh =(max_h-min_h)/(n_h-1);
%dDxdx = diff(dX,1,1)/dx; dDxdx = (cat(2,dDxdx(:,1,:),dDxdx)+cat(2,dDxdx,dDxdx(:,size(dDxdx,2),:)))/2;
%dDydy = diff(dY,1,1)/dy; dDydy = (cat(1,dDydy(1,:,:),dDydy)+cat(1,dDydy,dDydy(size(dDydy,1),:,:)))/2;
%dDzdz = diff(dZ,1,3)/dz; dDzdz = (cat(3,dDzdz(:,:,1),dDzdz)+cat(3,dDzdz,dDzdz(:,:,size(dDzdz,3))))/2;
%JacDet = (1+dDxdx).*(1+dDydy).*(1+dDzdz); % Voxel volume factor in warped images

%maxjd = 3; % maximum Jacobian density correction
%JacDet(find(JacDet<0)) = 0;
%JacDet(find(JacDet>maxjd)) = maxjd;
    
%voldL.dimr=n_p;
%voldL.dimc=n_l;
%voldL.dimd=n_h;
[voldL.dimr voldL.dimc voldL.dimd]=size(dL);
    
voldL.vx=dl;
voldL.vy=dp;
voldL.vz=dh;
voldL.slicegap=0;
voldL.SagDir=1;
voldL.CorDir=2;
voldL.AxlDir=3;
% Siemens's shperical harmonic is in LAF coordinates.
voldL.DirRow=[1;0;0];
voldL.DirCol=[0;1;0];
voldL.DirDep=[0;0;1];
voldL.lphcent=1000*[(max_l+min_l)/2;(max_p+min_p)/2;(max_h+min_h)/2];

Mvxl2lph=eye(4,4);

% Row direction vector
Mvxl2lph(:,2)=voldL.vx*[voldL.DirRow;0];
Mvxl2lph(:,1)=voldL.vy*[voldL.DirCol;0];
%Slice direction vector
Mvxl2lph(:,3)=(voldL.vz+voldL.slicegap)*[voldL.DirDep;0];

%For matlab Index sake: start from 1
T=Mvxl2lph*[-(voldL.dimr+1)/2; -(voldL.dimc+1)/2; -(voldL.dimd+1)/2;1];
Mvxl2lph(:,4)=T+[voldL.lphcent;0];
voldL.Mvxl2lph=Mvxl2lph;
voldL.imgs=zeros(voldL.dimr,voldL.dimc,voldL.dimd);
voldL.imgs=dL;
voldL.minI=min(voldL.imgs(:));
voldL.maxI=max(voldL.imgs(:));

voldP=voldL;
voldP.imgs=dP;
voldP.minI=min(voldP.imgs(:));
voldP.maxI=max(voldP.imgs(:));

voldH=voldL;
voldH.imgs=dH;
voldH.minI=min(voldH.imgs(:));
voldH.maxI=max(voldH.imgs(:));

% volJX=voldL;
% volJX.imgs=1+dDxdx;
% volJX.minI=min(volJX.imgs(:));
% volJX.maxI=max(volJX.imgs(:));
% 
% volJY=voldL;
% volJY.imgs=1+dDydy;
% volJY.minI=min(volJY.imgs(:));
% volJY.maxI=max(volJY.imgs(:));
% 
% volJZ=voldL;
% volJZ.imgs=1+dDzdz;
% volJZ.minI=min(volJZ.imgs(:));
% volJZ.maxI=max(volJZ.imgs(:));

QD_ctx_save_mgh(voldL, dlfn);
QD_ctx_save_mgh(voldP, dpfn);
QD_ctx_save_mgh(voldH, dhfn);

% write_mgh(jxfn, volJX,3);
% write_mgh(jyfn, volJY,3);
% write_mgh(jzfn, volJZ,3);

%write_mgh(jacdetfn, volJacDet,3)
